---
title: "SIBER Analysis of Coral Physiology"
author: "Peter Flood and Serena Hackerott"
date: "2/8/2024"
output:
  html_document:
    toc: yes
    df_print: paged
  html_notebook:
    toc: yes
    toc_float: yes
---

# Setup

```{r Setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
getwd()
```


### Load Packages
```{r}
##Install Packages if Needed
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("cowplot")) install.packages("cowplot")
if (!require("SIBER")) install.packages("SIBER")
if (!require("vegan")) install.packages("vegan")
if (!require("Hmisc")) install.packages("Hmisc")
if (!require("corrplot")) install.packages("corrplot")
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("Rmisc")) install.packages("Rmisc")
if (!require("ggpubr")) install.packages("ggpubr")

##Load Packages
library(ggplot2) #Required for ggplots
library(cowplot) #Required for plotting panel figures
library(SIBER) #Required for generating physiological ellipses and percent overlap calculations
library(vegan) #Required for NMDS
library(Hmisc) #Required for correlations
library(corrplot) #Required for correlation plot
library(tidyverse) #Required for data manipulation
library(Rmisc) #Required for data summary
library(ggpubr) #Required for stat_conf_ellipse
```


# Sample Data and Metadata

### Load and Organize Data
```{r}
##Load Data
#Note: Physiological metrics calculated in 02_PhysiologyMetrics.R file
Phys<-read.csv("Outputs/CoralData.csv", header=TRUE)

##Set factor variables
Phys$TimeP<-factor(Phys$TimeP, levels=c("TP1", "TP2", "TP3", "TP4"))
Phys$Site<-factor(Phys$Site, levels=c("KL", "SS"))
Phys$Genotype<-factor(Phys$Genotype, levels=c("AC8", "AC10", "AC12"))
Phys$Orig<-factor(Phys$Orig, levels=c("N", "T"))
Phys$Origin<-factor(Phys$Origin, levels=c("Native", "Transplant"))
Phys$Site.Orig<-factor(Phys$Site.Orig, levels=c("KL.N", "KL.T", "SS.N", "SS.T"))

```


### Check Correlation
```{r}
##Remove NA's
names(Phys)
Phys.rm<-na.omit(Phys)

##Log +1 transform 
Phys.log<-Phys.rm
Phys.log[,-c(1:10)]<-log(Phys.rm[,-c(1:10)]+1)
  
Phys.corr<-rcorr(as.matrix(Phys.log[,-c(1:10)]), type="pearson")
Phys.corr

diag(Phys.corr$P)<-0

corrplot(Phys.corr$r, type="upper", order="hclust", 
         p.mat = Phys.corr$P, sig.level = 0.01, insig = "blank")

```
Physiological variables of interest: Protein (Coral and Symbiont), Biomass (Coral and Symbiont), and Chlorophyll.


# SIBER Ellipses

## Prepare Input Data

### NMDS Ordination
SIBER runs on a two dimensional data set. So first, we need to reduce the dimensionality of the physiology data. We're going to do this via Non-Metric Multidimensional Scaling (NMDS) on log+1 transformed physiological metrics of interest.
```{r}
#Select only the physiology columns of interest (without covariates) to put into the NMDS
names(Phys.log)
phys.log.num <- Phys.log[,c(11:14, 16)]

#Run NMDS
phys.nmds <- metaMDS(phys.log.num, distance = "euclidean", k = 2, autotransform = F)

#Quick plot of NMDS output
ordiplot(phys.nmds)
```


### Data Prep for SIBER
```{r}
#Prepare data to be input into SIBER
phys.siber.input <- phys.nmds$points %>% #extract 2-D physiology axes from NMDS
  bind_cols(#add back covariates from original phys data
    select(Phys.log, ID:Site.Orig) #select those covariate columns
  ) %>% 
  #SIBER object needs four specific columns
  #iso1, iso2, group, and community
  #Need to manipulate the data to match that format
  #create  group variable that combines site, genotype and origin
  unite("group", c(Site, Genotype, Orig), sep = "_") %>% 
  #rename variables to match names for SIBER
  dplyr::rename(community = TimeP, iso1 = MDS1, iso2 = MDS2) %>% 
  #retain only columns for SIBER
  select(iso1, iso2, group, community)

```


## Run SIBER
Grouping by each genotype at each site, timepoint, and from each origin
```{r}
# create SIBER object
phys.siber.object <- createSiberObject(phys.siber.input)

# sample sizes by group
phys.siber.object[["sample.sizes"]]

# visualize SIBER groups

# Create lists of plotting arguments to be passed onwards to each 
# of the three plotting functions.
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, 
                             lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")


# ellipses and group.hulls are set to TRUE or T for short to force
# their plotting. 
par(mfrow=c(1,1))
plotSiberObject(phys.siber.object,
                  ax.pad = 2, 
                  hulls = F, community.hulls.args, 
                  ellipses = T, group.ellipses.args,
                  group.hulls = T, group.hull.args,
                  bty = "L",
                  iso.order = c(1,2),
                  xlab = expression({delta}^13*C~'permille'),
                  ylab = expression({delta}^15*N~'permille')
                  )

# You can add more ellipses by directly calling plot.group.ellipses()
# Add an additional p.interval % prediction ellilpse
plotGroupEllipses(phys.siber.object, n = 100, p.interval = 0.95,
                    lty = 1, lwd = 2)

# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(phys.siber.object, n = 100, p.interval = 0.95,
                  ci.mean = T, lty = 1, lwd = 2)

# Calculate sumamry statistics for each group: TA, SEA and SEAc
group.ML <- groupMetricsML(phys.siber.object)
print(group.ML)

legend("topright", colnames(group.ML), 
       pch = c(1,1,1,2,2,2), col = c(1:3, 1:3), lty = 1)

##Save SIBER Object in Outputs
save(phys.siber.object, file="Outputs/SIBER/Phys.SIBER.Object.RData")
```


# Ellipse Overlap

## Calculate Percent Overlap
Calculating the overlap between corals of the same genotype, at the same site and timepoint.
Do native and transplant fragments become more similar over time within each genotype at each site?
Note: overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2


### Klein

#### KL_AC10

Native and transplant overlap at time 1
```{r}
overlap.kl.ac10.tp1.n.t <- maxLikOverlap("TP1.KL_AC10_N", "TP1.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp1.n.t <- as.numeric(overlap.kl.ac10.tp1.n.t["overlap"] / 
                            (overlap.kl.ac10.tp1.n.t["area.1"]+
                               overlap.kl.ac10.tp1.n.t["area.2"]-
                               overlap.kl.ac10.tp1.n.t["overlap"])) #subtract overlap 
```

Native and transplant overlap at time 2
```{r}
overlap.kl.ac10.tp2.n.t <- maxLikOverlap("TP2.KL_AC10_N", "TP2.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp2.n.t <- as.numeric(overlap.kl.ac10.tp2.n.t["overlap"] / 
                            (overlap.kl.ac10.tp2.n.t["area.1"]+
                               overlap.kl.ac10.tp2.n.t["area.2"]-
                               overlap.kl.ac10.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.kl.ac10.tp3.n.t <- maxLikOverlap("TP3.KL_AC10_N", "TP3.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp3.n.t <- as.numeric(overlap.kl.ac10.tp3.n.t["overlap"] / 
                            (overlap.kl.ac10.tp3.n.t["area.1"]+
                               overlap.kl.ac10.tp3.n.t["area.2"]-
                               overlap.kl.ac10.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.kl.ac10.tp4.n.t <- maxLikOverlap("TP4.KL_AC10_N", "TP4.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp4.n.t <- as.numeric(overlap.kl.ac10.tp4.n.t["overlap"] / 
                            (overlap.kl.ac10.tp4.n.t["area.1"]+
                               overlap.kl.ac10.tp4.n.t["area.2"]-
                               overlap.kl.ac10.tp4.n.t["overlap"]))
```


#### KL_AC8

Native and transplant overlap at time 1
```{r}
overlap.kl.ac8.tp1.n.t <- maxLikOverlap("TP1.KL_AC8_N", "TP1.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp1.n.t <- as.numeric(overlap.kl.ac8.tp1.n.t["overlap"] / 
                            (overlap.kl.ac8.tp1.n.t["area.1"]+
                               overlap.kl.ac8.tp1.n.t["area.2"]-
                               overlap.kl.ac8.tp1.n.t["overlap"])) #subtract overlap 
```

Native and transplant overlap at time 2
```{r}
overlap.kl.ac8.tp2.n.t <- maxLikOverlap("TP2.KL_AC8_N", "TP2.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp2.n.t <- as.numeric(overlap.kl.ac8.tp2.n.t["overlap"] / 
                            (overlap.kl.ac8.tp2.n.t["area.1"]+
                               overlap.kl.ac8.tp2.n.t["area.2"]-
                               overlap.kl.ac8.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.kl.ac8.tp3.n.t <- maxLikOverlap("TP3.KL_AC8_N", "TP3.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp3.n.t <- as.numeric(overlap.kl.ac8.tp3.n.t["overlap"] / 
                            (overlap.kl.ac8.tp3.n.t["area.1"]+
                               overlap.kl.ac8.tp3.n.t["area.2"]-
                               overlap.kl.ac8.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.kl.ac8.tp4.n.t <- maxLikOverlap("TP4.KL_AC8_N", "TP4.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp4.n.t <- as.numeric(overlap.kl.ac8.tp4.n.t["overlap"] / 
                            (overlap.kl.ac8.tp4.n.t["area.1"]+
                               overlap.kl.ac8.tp4.n.t["area.2"]-
                               overlap.kl.ac8.tp4.n.t["overlap"]))
```


#### KL_AC12

Native and transplant overlap at time 1
```{r}
overlap.kl.ac12.tp1.n.t <- maxLikOverlap("TP1.KL_AC12_N", "TP1.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp1.n.t <- as.numeric(overlap.kl.ac12.tp1.n.t["overlap"] / 
                            (overlap.kl.ac12.tp1.n.t["area.1"]+
                               overlap.kl.ac12.tp1.n.t["area.2"]-
                               overlap.kl.ac12.tp1.n.t["overlap"])) #subtract overlap 
```

Native and transplant overlap at time 2
```{r}
overlap.kl.ac12.tp2.n.t <- maxLikOverlap("TP2.KL_AC12_N", "TP2.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp2.n.t <- as.numeric(overlap.kl.ac12.tp2.n.t["overlap"] / 
                            (overlap.kl.ac12.tp2.n.t["area.1"]+
                               overlap.kl.ac12.tp2.n.t["area.2"]-
                               overlap.kl.ac12.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.kl.ac12.tp3.n.t <- maxLikOverlap("TP3.KL_AC12_N", "TP3.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp3.n.t <- as.numeric(overlap.kl.ac12.tp3.n.t["overlap"] / 
                            (overlap.kl.ac12.tp3.n.t["area.1"]+
                               overlap.kl.ac12.tp3.n.t["area.2"]-
                               overlap.kl.ac12.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.kl.ac12.tp4.n.t <- maxLikOverlap("TP4.KL_AC12_N", "TP4.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp4.n.t <- as.numeric(overlap.kl.ac12.tp4.n.t["overlap"] / 
                            (overlap.kl.ac12.tp4.n.t["area.1"]+
                               overlap.kl.ac12.tp4.n.t["area.2"]-
                               overlap.kl.ac12.tp4.n.t["overlap"]))
```


### Something Special

#### SS_AC10

Native and transplant overlap at time 1
```{r}
overlap.ss.ac10.tp1.n.t <- maxLikOverlap("TP1.SS_AC10_N", "TP1.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp1.n.t <- as.numeric(overlap.ss.ac10.tp1.n.t["overlap"] / 
                            (overlap.ss.ac10.tp1.n.t["area.1"]+
                               overlap.ss.ac10.tp1.n.t["area.2"]-
                               overlap.ss.ac10.tp1.n.t["overlap"])) #subtract overlap 
```

Native and transplant overlap at time 2
```{r}
overlap.ss.ac10.tp2.n.t <- maxLikOverlap("TP2.SS_AC10_N", "TP2.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp2.n.t <- as.numeric(overlap.ss.ac10.tp2.n.t["overlap"] / 
                            (overlap.ss.ac10.tp2.n.t["area.1"]+
                               overlap.ss.ac10.tp2.n.t["area.2"]-
                               overlap.ss.ac10.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.ss.ac10.tp3.n.t <- maxLikOverlap("TP3.SS_AC10_N", "TP3.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp3.n.t <- as.numeric(overlap.ss.ac10.tp3.n.t["overlap"] / 
                            (overlap.ss.ac10.tp3.n.t["area.1"]+
                               overlap.ss.ac10.tp3.n.t["area.2"]-
                               overlap.ss.ac10.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.ss.ac10.tp4.n.t <- maxLikOverlap("TP4.SS_AC10_N", "TP4.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp4.n.t <- as.numeric(overlap.ss.ac10.tp4.n.t["overlap"] / 
                            (overlap.ss.ac10.tp4.n.t["area.1"]+
                               overlap.ss.ac10.tp4.n.t["area.2"]-
                               overlap.ss.ac10.tp4.n.t["overlap"]))
```


#### SS_AC8

Native and transplant overlap at time 1
```{r}
overlap.ss.ac8.tp1.n.t <- maxLikOverlap("TP1.SS_AC8_N", "TP1.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp1.n.t <- as.numeric(overlap.ss.ac8.tp1.n.t["overlap"] / 
                            (overlap.ss.ac8.tp1.n.t["area.1"]+
                               overlap.ss.ac8.tp1.n.t["area.2"]-
                               overlap.ss.ac8.tp1.n.t["overlap"])) #subtract overlap 
```

Native and transplant overlap at time 2
```{r}
overlap.ss.ac8.tp2.n.t <- maxLikOverlap("TP2.SS_AC8_N", "TP2.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp2.n.t <- as.numeric(overlap.ss.ac8.tp2.n.t["overlap"] / 
                            (overlap.ss.ac8.tp2.n.t["area.1"]+
                               overlap.ss.ac8.tp2.n.t["area.2"]-
                               overlap.ss.ac8.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.ss.ac8.tp3.n.t <- maxLikOverlap("TP3.SS_AC8_N", "TP3.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp3.n.t <- as.numeric(overlap.ss.ac8.tp3.n.t["overlap"] / 
                            (overlap.ss.ac8.tp3.n.t["area.1"]+
                               overlap.ss.ac8.tp3.n.t["area.2"]-
                               overlap.ss.ac8.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.ss.ac8.tp4.n.t <- maxLikOverlap("TP4.SS_AC8_N", "TP4.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp4.n.t <- as.numeric(overlap.ss.ac8.tp4.n.t["overlap"] / 
                            (overlap.ss.ac8.tp4.n.t["area.1"]+
                               overlap.ss.ac8.tp4.n.t["area.2"]-
                               overlap.ss.ac8.tp4.n.t["overlap"]))
```


#### SS_AC12

Native and transplant overlap at time 1
```{r}
overlap.ss.ac12.tp1.n.t <- maxLikOverlap("TP1.SS_AC12_N", "TP1.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp1.n.t <- as.numeric(overlap.ss.ac12.tp1.n.t["overlap"] / 
                            (overlap.ss.ac12.tp1.n.t["area.1"]+
                               overlap.ss.ac12.tp1.n.t["area.2"]-
                               overlap.ss.ac12.tp1.n.t["overlap"])) #subtract overlap 
```

Native and transplant overlap at time 2
```{r}
overlap.ss.ac12.tp2.n.t <- maxLikOverlap("TP2.SS_AC12_N", "TP2.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp2.n.t <- as.numeric(overlap.ss.ac12.tp2.n.t["overlap"] / 
                            (overlap.ss.ac12.tp2.n.t["area.1"]+
                               overlap.ss.ac12.tp2.n.t["area.2"]-
                               overlap.ss.ac12.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.ss.ac12.tp3.n.t <- maxLikOverlap("TP3.SS_AC12_N", "TP3.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp3.n.t <- as.numeric(overlap.ss.ac12.tp3.n.t["overlap"] / 
                            (overlap.ss.ac12.tp3.n.t["area.1"]+
                               overlap.ss.ac12.tp3.n.t["area.2"]-
                               overlap.ss.ac12.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.ss.ac12.tp4.n.t <- maxLikOverlap("TP4.SS_AC12_N", "TP4.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp4.n.t <- as.numeric(overlap.ss.ac12.tp4.n.t["overlap"] / 
                            (overlap.ss.ac12.tp4.n.t["area.1"]+
                               overlap.ss.ac12.tp4.n.t["area.2"]-
                               overlap.ss.ac12.tp4.n.t["overlap"]))
```


### Create Percent Overlap Dataframe
```{r}
#create vector of all overlaps
p.overlap <- c(
  p.overlap.kl.ac10.tp1.n.t, p.overlap.kl.ac10.tp2.n.t, p.overlap.kl.ac10.tp3.n.t, p.overlap.kl.ac10.tp4.n.t,
  p.overlap.kl.ac8.tp1.n.t, p.overlap.kl.ac8.tp2.n.t, p.overlap.kl.ac8.tp3.n.t, p.overlap.kl.ac8.tp4.n.t,
  p.overlap.kl.ac12.tp1.n.t, p.overlap.kl.ac12.tp2.n.t, p.overlap.kl.ac12.tp3.n.t, p.overlap.kl.ac12.tp4.n.t,
  p.overlap.ss.ac10.tp1.n.t, p.overlap.ss.ac10.tp2.n.t, p.overlap.ss.ac10.tp3.n.t, p.overlap.ss.ac10.tp4.n.t,
  p.overlap.ss.ac8.tp1.n.t, p.overlap.ss.ac8.tp2.n.t, p.overlap.ss.ac8.tp3.n.t, p.overlap.ss.ac8.tp4.n.t,
  p.overlap.ss.ac12.tp1.n.t, p.overlap.ss.ac12.tp2.n.t, p.overlap.ss.ac12.tp3.n.t, p.overlap.ss.ac12.tp4.n.t
)

#create vector of names for all overlaps
p.overlap.names <- c(
  "KL.AC10.TP1", "KL.AC10.TP2", "KL.AC10.TP3", "KL.AC10.TP4",
  "KL.AC8.TP1", "KL.AC8.TP2", "KL.AC8.TP3", "KL.AC8.TP4",
  "KL.AC12.TP1", "KL.AC12.TP2", "KL.AC12.TP3", "KL.AC12.TP4",
  "SS.AC10.TP1", "SS.AC10.TP2", "SS.AC10.TP3", "SS.AC10.TP4",
  "SS.AC8.TP1", "SS.AC8.TP2", "SS.AC8.TP3", "SS.AC8.TP4",
  "SS.AC12.TP1", "SS.AC12.TP2", "SS.AC12.TP3", "SS.AC12.TP4"
)
#bind into one data frame
p.overlap.df <- data.frame(Set=p.overlap.names, Overlap=p.overlap)
p.overlap.df<- p.overlap.df %>% tidyr::separate_wider_delim(cols="Set", names = c("Site", "Genotype", "TimeP"), delim = ".") #separate the names column into its pieces

##Write out dataframe
write.csv(p.overlap.df, "Outputs/SIBER_p.Overlap.csv", row.names=FALSE)

##Set factor variables
p.overlap.df$TimeP<-factor(p.overlap.df$TimeP, levels=c("TP1", "TP2", "TP3", "TP4"), ordered=TRUE)
p.overlap.df$Site<-factor(p.overlap.df$Site, levels=c("KL", "SS"))
p.overlap.df$Genotype<-factor(p.overlap.df$Genotype, levels=c("AC8", "AC10", "AC12"))

```


## Visualize Overlap over Time

### By Genotype
```{r Plot Overlap over Time}
##Plot Niche Overlap across Timepoints
Overlap.plot<-ggplot(p.overlap.df, aes(x=TimeP, y=Overlap, colour=Genotype, group=Genotype)) + 
  geom_line(linewidth=bar.sz)+
  geom_point(size=point.sz)+
  theme_classic()+
  theme(axis.title.x = element_text(size = axis.title.sz), 
        axis.title.y = element_text(size = axis.title.sz), 
        axis.text.x=element_text(size=axis.txt.sz, colour="black"),
        axis.text.y=element_text(size=axis.txt.sz, colour="black"), 
        legend.text=element_text(size=leg.txt.sz), 
        legend.title=element_text(size=leg.title.sz), 
        legend.box.background = element_rect(color = "black"), 
        strip.text=element_text(size=axis.title.sz))+
  labs(x="Timepoint", y="Physiological Niche Overlap")+
  facet_wrap(~Site); Overlap.plot

##Save Figure
ggsave(filename="Figures/04_SIBER/NicheOverlap.png", plot=Overlap.plot, dpi=300, width=8, height=5, units="in")

```



### Across Genotypes
```{r Plot Average Overlap over Time}
##Summary statistics by Site and Origin
p.overlap.sum<-summarySE(p.overlap.df, measurevar="Overlap", groupvars=c("Site", "TimeP"), na.rm=TRUE)

##Plot Average Niche Overlap across Timepoints
Overlap_Avg.plot<-ggplot(p.overlap.sum, aes(x=TimeP, y=Overlap, colour=Site, group=1)) + 
  scale_colour_manual(values=Site.colors.o)+
  geom_errorbar(aes(ymin=Overlap-se, ymax=Overlap+se), width=cap.sz, linewidth=bar.sz) +
  geom_line(linewidth=bar.sz)+
  geom_point(size=point.sz)+
  theme_classic()+
  theme(axis.title.x = element_text(size = axis.title.sz), 
        axis.title.y = element_text(size = axis.title.sz), 
        axis.text.x=element_text(size=axis.txt.sz, colour="black"),
        axis.text.y=element_text(size=axis.txt.sz, colour="black"), 
        legend.position="none",
        strip.text=element_text(size=axis.title.sz))+
  labs(x="Timepoint", y="Physiological Niche Overlap")+
  facet_wrap(~Site); Overlap_Avg.plot

##Save Figure
ggsave(filename="Figures/04_SIBER/AvgNicheOverlap.png", plot=Overlap_Avg.plot, dpi=300, width=6, height=5, units="in")
```


## Ellipses
Note: to Create SIBER Ellipses, run SIBER_Ellipse.R in Outputs/SIBER
Requires phys.ellipses.posterior created in SIBER_Ellipse.R in Outputs/SIBER

### Organize Ellipse Data
```{r}
##Load Ellipse Data
load("Outputs/SIBER/Phys.SIBER.Ellipses.RData")

# how many of the posterior draws do you want?
n.posts <- 100

# decide how big an ellipse you want to draw
p.ell <- 0.99

# for a standard ellipse use
# p.ell <- pchisq(1,2)

# a list to store the results
all_ellipses <- list()

# loop over groups
for (i in 1:length(phys.ellipses.posterior)){
  
  # a dummy variable to build in the loop
  ell <- NULL
  post.id <- NULL
  
  for ( j in 1:n.posts){
    
    # covariance matrix
    Sigma  <- matrix(phys.ellipses.posterior[[i]][j,1:4], 2, 2)
    
    # mean
    mu     <- phys.ellipses.posterior[[i]][j,5:6]
    
    # ellipse points
    out <- ellipse::ellipse(Sigma, centre = mu , level = p.ell)
    
    ell <- rbind(ell, out)
    post.id <- c(post.id, rep(j, nrow(out)))
    
  }
  ell <- as.data.frame(ell)
  ell$rep <- post.id
  all_ellipses[[i]] <- ell
}

ellipse_df <- bind_rows(all_ellipses, .id = "id")

# now we need the group and community names

# extract them from the global.ellipses.posterior list
group_comm_names <- names(phys.ellipses.posterior)[as.numeric(ellipse_df$id)]

# split them and convert to a matrix
split_group_comm <- matrix(
         unlist(regmatches(group_comm_names, regexpr("[.]", group_comm_names), invert = TRUE)),
                           nrow(ellipse_df), 2, byrow = TRUE)

ellipse_df$community <- split_group_comm[,1]
ellipse_df$group     <- split_group_comm[,2]

ellipse_df <- dplyr::rename(ellipse_df, iso1 = x, iso2 = y)

plot.ellipse.df <- ellipse_df %>% 
  separate_wider_delim(cols="group", names = c("Site", "Genotype", "Origin"), delim = "_") %>% 
  dplyr::rename(TimeP = community, MDS1 = iso1, MDS2 = iso2)

##Write out dataframe
write.csv(plot.ellipse.df, "Outputs/SIBER_Ellipse.csv", row.names=FALSE)

```


### Plot Niche Ellipses

```{r Plot Ellipses over Time}
#example niche ellipse plots 
phys.niche.ellipse.plot <- ggplot(plot.ellipse.df,
                                  aes(x = MDS1, y = MDS2, color = Origin, fill = Genotype))+
    stat_conf_ellipse(geom = "polygon")+
    facet_grid(Site ~ TimeP, scales = "free")+
    scale_fill_viridis_d(end = 0.8)+
    scale_color_viridis_d(end = 0.8, option = "A")+
    theme_bw();phys.niche.ellipse.plot

##Save Figure
ggsave(filename="Figures/04_SIBER/NicheEllipse.png", plot=phys.niche.ellipse.plot, dpi=300, width=10, height=8, units="in")
```


# Figures
Need to decide on final figure panels