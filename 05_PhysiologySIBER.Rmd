---
title: "SIBER Analysis of Coral Physiology"
author: "Peter Flood and Serena Hackerott"
date: "2/8/2024"
output:
  html_notebook:
    toc: yes
    toc_float: yes
  html_document:
    toc: yes
    df_print: paged
---

# Setup

```{r Setup, include = FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```


### Load Packages
```{r}
##Install Packages if Needed
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("cowplot")) install.packages("cowplot")
if (!require("SIBER")) install.packages("SIBER")
if (!require("vegan")) install.packages("vegan")
if (!require("tidyverse")) install.packages("tidyverse")


##Load Packages
library(ggplot2) #Required for ggplots
library(cowplot) #Required for plotting panel figures
library(SIBER) #Required for generating physiological ellipses and percent overlap calculations
library(vegan) #Required for NMDS
library(Hmisc) #Required for correlations
library(corrplot) #Required for correlation plot
library(tidyverse) #Required for data manipulation
```


# Sample Data and Metadata

### Load and Organize Data
```{r}
##Load Data
#Note: Physiological metrics calculated in 02_PhysiologyMetrics.R file
Phys<-read.csv("Outputs/CoralData.csv", header=TRUE)

##Set factor variables
Phys$TimeP<-factor(Phys$TimeP, levels=c("TP1", "TP2", "TP3", "TP4"))
Phys$Site<-factor(Phys$Site, levels=c("KL", "SS"))
Phys$Genotype<-factor(Phys$Genotype, levels=c("AC8", "AC10", "AC12"))
Phys$Orig<-factor(Phys$Orig, levels=c("N", "T"))
Phys$Origin<-factor(Phys$Origin, levels=c("Native", "Transplant"))
Phys$Site.Orig<-factor(Phys$Site.Orig, levels=c("KL.N", "KL.T", "SS.N", "SS.T"))

```


### Check Correlation
```{r}
##Remove NA's
names(Phys)
Phys.rm<-na.omit(Phys)

##Log +1 transform 
Phys.log<-Phys.rm
Phys.log[,-c(1:10)]<-log(Phys.rm[,-c(1:10)]+1)
  
Phys.corr<-rcorr(as.matrix(Phys.log[,-c(1:10)]), type="pearson")
Phys.corr

diag(Phys.corr$P)<-0

corrplot(Phys.corr$r, type="upper", order="hclust", 
         p.mat = Phys.corr$P, sig.level = 0.01, insig = "blank")

```


# SIBER Ellipses

## SIBER Prep

### Ordination
```{r}
#SIBER runs on a two dimensional data set
#So, first we need to reduce the dimensionality of the physiology data
#We're going to do this via Non-Metric Multidimensional Scaling (NMDS) 

#Select only the physiology columns (numbers only without covariates) to put into the NMDS
phys.log.num <- Phys.log %>% select(SA_cm2:Chl_ug.cm2)

#Run NMDS
phys.nmds <- metaMDS(phys.log.num, distance = "euclidean", k = 2, autotransform = F)

#Quick plot of NMDS output
ordiplot(phys.nmds)
```
### Data Prep for SIBER
```{r}
#Prepare data to be input into SIBER
phys.siber.input <- phys.nmds$points %>% #extract 2-D physiology axes from NMDS
  bind_cols(#add back covariates from original phys data
    select(Phys.log, ID:Site.Orig) #select those covariate columns
  ) %>% 
  #SIBER object needs four specific columns
  #iso1, iso2, group, and community
  #Need to manipulate the data to match that format
  #create  group variable that combines site, genotype and origin
  unite("group", c(Site, Genotype, Orig), sep = "_") %>% 
  #rename variables to match names for SIBER
  rename(community = TimeP, iso1 = MDS1, iso2 = MDS2) %>% 
  #retain only columns for SIBER
  select(iso1, iso2, group, community)

```


### Run SIBER
Grouping by each genotype at each site, timepoint, and from each origin
```{r}
# create SIBER object
phys.siber.object <- createSiberObject(phys.siber.input)

# sample sizes by group
phys.siber.object[["sample.sizes"]]

# visualize SIBER groups

# Create lists of plotting arguments to be passed onwards to each 
# of the three plotting functions.
community.hulls.args <- list(col = 1, lty = 1, lwd = 1)
group.ellipses.args  <- list(n = 100, p.interval = 0.95, 
                             lty = 1, lwd = 2)
group.hull.args      <- list(lty = 2, col = "grey20")


# ellipses and group.hulls are set to TRUE or T for short to force
# their plotting. 
par(mfrow=c(1,1))
plotSiberObject(phys.siber.object,
                  ax.pad = 2, 
                  hulls = F, community.hulls.args, 
                  ellipses = T, group.ellipses.args,
                  group.hulls = T, group.hull.args,
                  bty = "L",
                  iso.order = c(1,2),
                  xlab = expression({delta}^13*C~'permille'),
                  ylab = expression({delta}^15*N~'permille')
                  )

# You can add more ellipses by directly calling plot.group.ellipses()
# Add an additional p.interval % prediction ellilpse
plotGroupEllipses(phys.siber.object, n = 100, p.interval = 0.95,
                    lty = 1, lwd = 2)

# or you can add the XX% confidence interval around the bivariate means
# by specifying ci.mean = T along with whatever p.interval you want.
plotGroupEllipses(phys.siber.object, n = 100, p.interval = 0.95,
                  ci.mean = T, lty = 1, lwd = 2)

# Calculate sumamry statistics for each group: TA, SEA and SEAc
group.ML <- groupMetricsML(phys.siber.object)
print(group.ML)

legend("topright", colnames(group.ML), 
       pch = c(1,1,1,2,2,2), col = c(1:3, 1:3), lty = 1)
```

```{r}
set up the model parameters
options for running jags
parms <- list()
parms$n.iter <- 2 * 10^6   # number of iterations to run the model for
parms$n.burnin <- 1 * 10^4 # discard the first set of values
parms$n.thin <- 100     # thin the posterior by this many
parms$n.chains <- 2        # run this many chains
parms$save.output = T
parms$save.dir = getwd()

# define the priors
priors <- list()
priors$R <- 1 * diag(2)
priors$k <- 2
priors$tau.mu <- 1.0E-3

#SIBER generates a lot of jags output
#changing working directory to where that output should go
setwd("~/Bonaire_memory/Outputs/SIBER")
#knitr::opts_knit$set(root.dir = "~/Bonaire_memory/Outputs/SIBER")

# fit the ellipses which uses an Inverse Wishart prior
# on the covariance matrix Sigma, and a vague normal prior on the
# means. Fitting is via the JAGS method.
phys.ellipses.posterior <- siberMVN(phys.siber.object, parms, priors)

#calculate posterior estimates of ellipses for all groups
SEA.B<-siberEllipses(phys.ellipses.posterior)
#set column names for SEA.B
colnames(SEA.B)<-names(phys.ellipses.posterior)

```

### Plot Ellipses over Time

#### TP1

#### TP2

#### TP3

#### TP4


# Ellipse Overlap

### Calculate Percent Overlap
Do native and transplant fragments become more similar over time
within each genotype at each site

######KL_AC10

Native and transplant overlap at time 1
```{r}
overlap.kl.ac10.tp1.n.t <- maxLikOverlap("TP1.KL_AC10_N", "TP1.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp1.n.t <- as.numeric(overlap.kl.ac10.tp1.n.t["overlap"] / 
                            (overlap.kl.ac10.tp1.n.t["area.1"]+
                               overlap.kl.ac10.tp1.n.t["area.2"]-
                               overlap.kl.ac10.tp1.n.t["overlap"])) #overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2
```

Native and transplant overlap at time 2
```{r}
overlap.kl.ac10.tp2.n.t <- maxLikOverlap("TP2.KL_AC10_N", "TP2.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp2.n.t <- as.numeric(overlap.kl.ac10.tp2.n.t["overlap"] / 
                            (overlap.kl.ac10.tp2.n.t["area.1"]+
                               overlap.kl.ac10.tp2.n.t["area.2"]-
                               overlap.kl.ac10.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.kl.ac10.tp3.n.t <- maxLikOverlap("TP3.KL_AC10_N", "TP3.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp3.n.t <- as.numeric(overlap.kl.ac10.tp3.n.t["overlap"] / 
                            (overlap.kl.ac10.tp3.n.t["area.1"]+
                               overlap.kl.ac10.tp3.n.t["area.2"]-
                               overlap.kl.ac10.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.kl.ac10.tp4.n.t <- maxLikOverlap("TP4.KL_AC10_N", "TP4.KL_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac10.tp4.n.t <- as.numeric(overlap.kl.ac10.tp4.n.t["overlap"] / 
                            (overlap.kl.ac10.tp4.n.t["area.1"]+
                               overlap.kl.ac10.tp4.n.t["area.2"]-
                               overlap.kl.ac10.tp4.n.t["overlap"]))
```

######KL_AC8

Native and transplant overlap at time 1
```{r}
overlap.kl.ac8.tp1.n.t <- maxLikOverlap("TP1.KL_AC8_N", "TP1.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp1.n.t <- as.numeric(overlap.kl.ac8.tp1.n.t["overlap"] / 
                            (overlap.kl.ac8.tp1.n.t["area.1"]+
                               overlap.kl.ac8.tp1.n.t["area.2"]-
                               overlap.kl.ac8.tp1.n.t["overlap"])) #overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2
```

Native and transplant overlap at time 2
```{r}
overlap.kl.ac8.tp2.n.t <- maxLikOverlap("TP2.KL_AC8_N", "TP2.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp2.n.t <- as.numeric(overlap.kl.ac8.tp2.n.t["overlap"] / 
                            (overlap.kl.ac8.tp2.n.t["area.1"]+
                               overlap.kl.ac8.tp2.n.t["area.2"]-
                               overlap.kl.ac8.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.kl.ac8.tp3.n.t <- maxLikOverlap("TP3.KL_AC8_N", "TP3.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp3.n.t <- as.numeric(overlap.kl.ac8.tp3.n.t["overlap"] / 
                            (overlap.kl.ac8.tp3.n.t["area.1"]+
                               overlap.kl.ac8.tp3.n.t["area.2"]-
                               overlap.kl.ac8.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.kl.ac8.tp4.n.t <- maxLikOverlap("TP4.KL_AC8_N", "TP4.KL_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac8.tp4.n.t <- as.numeric(overlap.kl.ac8.tp4.n.t["overlap"] / 
                            (overlap.kl.ac8.tp4.n.t["area.1"]+
                               overlap.kl.ac8.tp4.n.t["area.2"]-
                               overlap.kl.ac8.tp4.n.t["overlap"]))
```
######KL_AC12

Native and transplant overlap at time 1
```{r}
overlap.kl.ac12.tp1.n.t <- maxLikOverlap("TP1.KL_AC12_N", "TP1.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp1.n.t <- as.numeric(overlap.kl.ac12.tp1.n.t["overlap"] / 
                            (overlap.kl.ac12.tp1.n.t["area.1"]+
                               overlap.kl.ac12.tp1.n.t["area.2"]-
                               overlap.kl.ac12.tp1.n.t["overlap"])) #overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2
```

Native and transplant overlap at time 2
```{r}
overlap.kl.ac12.tp2.n.t <- maxLikOverlap("TP2.KL_AC12_N", "TP2.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp2.n.t <- as.numeric(overlap.kl.ac12.tp2.n.t["overlap"] / 
                            (overlap.kl.ac12.tp2.n.t["area.1"]+
                               overlap.kl.ac12.tp2.n.t["area.2"]-
                               overlap.kl.ac12.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.kl.ac12.tp3.n.t <- maxLikOverlap("TP3.KL_AC12_N", "TP3.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp3.n.t <- as.numeric(overlap.kl.ac12.tp3.n.t["overlap"] / 
                            (overlap.kl.ac12.tp3.n.t["area.1"]+
                               overlap.kl.ac12.tp3.n.t["area.2"]-
                               overlap.kl.ac12.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.kl.ac12.tp4.n.t <- maxLikOverlap("TP4.KL_AC12_N", "TP4.KL_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.kl.ac12.tp4.n.t <- as.numeric(overlap.kl.ac12.tp4.n.t["overlap"] / 
                            (overlap.kl.ac12.tp4.n.t["area.1"]+
                               overlap.kl.ac12.tp4.n.t["area.2"]-
                               overlap.kl.ac12.tp4.n.t["overlap"]))
```

######SS_AC10

Native and transplant overlap at time 1
```{r}
overlap.ss.ac10.tp1.n.t <- maxLikOverlap("TP1.SS_AC10_N", "TP1.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp1.n.t <- as.numeric(overlap.ss.ac10.tp1.n.t["overlap"] / 
                            (overlap.ss.ac10.tp1.n.t["area.1"]+
                               overlap.ss.ac10.tp1.n.t["area.2"]-
                               overlap.ss.ac10.tp1.n.t["overlap"])) #overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2
```

Native and transplant overlap at time 2
```{r}
overlap.ss.ac10.tp2.n.t <- maxLikOverlap("TP2.SS_AC10_N", "TP2.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp2.n.t <- as.numeric(overlap.ss.ac10.tp2.n.t["overlap"] / 
                            (overlap.ss.ac10.tp2.n.t["area.1"]+
                               overlap.ss.ac10.tp2.n.t["area.2"]-
                               overlap.ss.ac10.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.ss.ac10.tp3.n.t <- maxLikOverlap("TP3.SS_AC10_N", "TP3.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp3.n.t <- as.numeric(overlap.ss.ac10.tp3.n.t["overlap"] / 
                            (overlap.ss.ac10.tp3.n.t["area.1"]+
                               overlap.ss.ac10.tp3.n.t["area.2"]-
                               overlap.ss.ac10.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.ss.ac10.tp4.n.t <- maxLikOverlap("TP4.SS_AC10_N", "TP4.SS_AC10_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac10.tp4.n.t <- as.numeric(overlap.ss.ac10.tp4.n.t["overlap"] / 
                            (overlap.ss.ac10.tp4.n.t["area.1"]+
                               overlap.ss.ac10.tp4.n.t["area.2"]-
                               overlap.ss.ac10.tp4.n.t["overlap"]))
```

######SS_AC8

Native and transplant overlap at time 1
```{r}
overlap.ss.ac8.tp1.n.t <- maxLikOverlap("TP1.SS_AC8_N", "TP1.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp1.n.t <- as.numeric(overlap.ss.ac8.tp1.n.t["overlap"] / 
                            (overlap.ss.ac8.tp1.n.t["area.1"]+
                               overlap.ss.ac8.tp1.n.t["area.2"]-
                               overlap.ss.ac8.tp1.n.t["overlap"])) #overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2
```

Native and transplant overlap at time 2
```{r}
overlap.ss.ac8.tp2.n.t <- maxLikOverlap("TP2.SS_AC8_N", "TP2.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp2.n.t <- as.numeric(overlap.ss.ac8.tp2.n.t["overlap"] / 
                            (overlap.ss.ac8.tp2.n.t["area.1"]+
                               overlap.ss.ac8.tp2.n.t["area.2"]-
                               overlap.ss.ac8.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.ss.ac8.tp3.n.t <- maxLikOverlap("TP3.SS_AC8_N", "TP3.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp3.n.t <- as.numeric(overlap.ss.ac8.tp3.n.t["overlap"] / 
                            (overlap.ss.ac8.tp3.n.t["area.1"]+
                               overlap.ss.ac8.tp3.n.t["area.2"]-
                               overlap.ss.ac8.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.ss.ac8.tp4.n.t <- maxLikOverlap("TP4.SS_AC8_N", "TP4.SS_AC8_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac8.tp4.n.t <- as.numeric(overlap.ss.ac8.tp4.n.t["overlap"] / 
                            (overlap.ss.ac8.tp4.n.t["area.1"]+
                               overlap.ss.ac8.tp4.n.t["area.2"]-
                               overlap.ss.ac8.tp4.n.t["overlap"]))
```
######SS_AC12

Native and transplant overlap at time 1
```{r}
overlap.ss.ac12.tp1.n.t <- maxLikOverlap("TP1.SS_AC12_N", "TP1.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp1.n.t <- as.numeric(overlap.ss.ac12.tp1.n.t["overlap"] / 
                            (overlap.ss.ac12.tp1.n.t["area.1"]+
                               overlap.ss.ac12.tp1.n.t["area.2"]-
                               overlap.ss.ac12.tp1.n.t["overlap"])) #overlap is shared area between area.1 and area.2, if we don't subtract the overlap it would get counted twice into the total area of area.1 union area.2
```

Native and transplant overlap at time 2
```{r}
overlap.ss.ac12.tp2.n.t <- maxLikOverlap("TP2.SS_AC12_N", "TP2.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp2.n.t <- as.numeric(overlap.ss.ac12.tp2.n.t["overlap"] / 
                            (overlap.ss.ac12.tp2.n.t["area.1"]+
                               overlap.ss.ac12.tp2.n.t["area.2"]-
                               overlap.ss.ac12.tp2.n.t["overlap"]))
```

Native and transplant overlap at time 3
```{r}
overlap.ss.ac12.tp3.n.t <- maxLikOverlap("TP3.SS_AC12_N", "TP3.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp3.n.t <- as.numeric(overlap.ss.ac12.tp3.n.t["overlap"] / 
                            (overlap.ss.ac12.tp3.n.t["area.1"]+
                               overlap.ss.ac12.tp3.n.t["area.2"]-
                               overlap.ss.ac12.tp3.n.t["overlap"]))
```

Native and transplant overlap at time 4
```{r}
overlap.ss.ac12.tp4.n.t <- maxLikOverlap("TP4.SS_AC12_N", "TP4.SS_AC12_T", phys.siber.object,
                                   p = 0.95, n = 360)
p.overlap.ss.ac12.tp4.n.t <- as.numeric(overlap.ss.ac12.tp4.n.t["overlap"] / 
                            (overlap.ss.ac12.tp4.n.t["area.1"]+
                               overlap.ss.ac12.tp4.n.t["area.2"]-
                               overlap.ss.ac12.tp4.n.t["overlap"]))
```
### Create Percent Overlap Dataframe
```{r}
#create vector of all overlaps
p.overlap <- c(
  p.overlap.kl.ac10.tp1.n.t, p.overlap.kl.ac10.tp2.n.t, p.overlap.kl.ac10.tp3.n.t, p.overlap.kl.ac10.tp4.n.t,
  p.overlap.kl.ac8.tp1.n.t, p.overlap.kl.ac8.tp2.n.t, p.overlap.kl.ac8.tp3.n.t, p.overlap.kl.ac8.tp4.n.t,
  p.overlap.kl.ac12.tp1.n.t, p.overlap.kl.ac12.tp2.n.t, p.overlap.kl.ac12.tp3.n.t, p.overlap.kl.ac12.tp4.n.t,
  p.overlap.ss.ac10.tp1.n.t, p.overlap.ss.ac10.tp2.n.t, p.overlap.ss.ac10.tp3.n.t, p.overlap.ss.ac10.tp4.n.t,
  p.overlap.ss.ac8.tp1.n.t, p.overlap.ss.ac8.tp2.n.t, p.overlap.ss.ac8.tp3.n.t, p.overlap.ss.ac8.tp4.n.t,
  p.overlap.ss.ac12.tp1.n.t, p.overlap.ss.ac12.tp2.n.t, p.overlap.ss.ac12.tp3.n.t, p.overlap.ss.ac12.tp4.n.t
)

#create vector of names for all overlaps
p.overlap.names <- c(
  "kl.ac10.tp1.n.t", "kl.ac10.tp2.n.t", "kl.ac10.tp3.n.t", "kl.ac10.tp4.n.t",
  "kl.ac8.tp1.n.t", "kl.ac8.tp2.n.t", "kl.ac8.tp3.n.t", "kl.ac8.tp4.n.t",
  "kl.ac12.tp1.n.t", "kl.ac12.tp2.n.t", "kl.ac12.tp3.n.t", "kl.ac12.tp4.n.t",
  "ss.ac10.tp1.n.t", "ss.ac10.tp2.n.t", "ss.ac10.tp3.n.t", "ss.ac10.tp4.n.t",
  "ss.ac8.tp1.n.t", "ss.ac8.tp2.n.t", "ss.ac8.tp3.n.t", "ss.ac8.tp4.n.t",
  "ss.ac12.tp1.n.t", "ss.ac12.tp2.n.t", "ss.ac12.tp3.n.t", "ss.ac12.tp4.n.t"
)
#bind into one data frame and prep for other uses
p.overlap.df <- bind_cols(p.overlap, p.overlap.names) %>% #bind p.overlap and names together
  rename(p_overlap = "...1", names = "...2") %>% #rename columns
  #separate the names column into its pieces
  separate(names, into = c("Site", "Genotype", "Time Period", "Comparison"), sep = "[//.]") %>% 
  #edit contents of the columns we just created to match other tables and figures
  #need to capitalize letters
  mutate(across(c(Site:Comparison), toupper)) %>% 
  #create new column that is a numeric time period that represents "End"
  mutate(`Time Period` = case_when(
    `Time Period` == "TP1" ~ 1,
    `Time Period` == "TP2" ~ 2,
    `Time Period` == "TP3" ~ 3,
    `Time Period` == "TP4" ~ 4
  ),
  Comparison = gsub("N", "Native vs Transplant", Comparison))

```

# Figures

## Percent Overlap Through Time
```{r}
(p.overlap.tp.plot <- ggplot(data = p.overlap.df, 
                             aes(x = `Time Period`, y = p_overlap, color = Genotype))+
   geom_line()+
   #geom_boxplot()
   facet_wrap(~Site)+
   #scale_x_continuous(breaks = c(2, 3, 4))+
   labs(y = "Percent Overlap (Native vs Transplant)")+
   theme_bw()
)
```
```{r}
p.overlap.mean <- p.overlap.df %>% 
                               group_by(Site, `Time Period`) %>% 
                               summarise(mean = mean(p_overlap), sd = sd(p_overlap))

(p.overlap.tp.plot <- ggplot(data = p.overlap.mean, 
                             aes(x = `Time Period`, y = mean, color = Site))+
   geom_line()+
   geom_errorbar(aes(ymin = mean - sd, ymax = mean + sd), width = 0.2)+
   #geom_boxplot()
   #facet_wrap(~Site)+
   #scale_x_continuous(breaks = c(2, 3, 4))+
   scale_color_manual(values = c(Site.colors.o))+
   labs(y = "Percent Overlap (Native vs Transplant)")+
   theme_bw()
)
```
##Ellipses
```{r}
# how many of the posterior draws do you want?
n.posts <- 100

# decide how big an ellipse you want to draw
p.ell <- 0.99

# for a standard ellipse use
# p.ell <- pchisq(1,2)




# a list to store the results
all_ellipses <- list()

# loop over groups
for (i in 1:length(phys.ellipses.posterior)){
  
  # a dummy variable to build in the loop
  ell <- NULL
  post.id <- NULL
  
  for ( j in 1:n.posts){
    
    # covariance matrix
    Sigma  <- matrix(phys.ellipses.posterior[[i]][j,1:4], 2, 2)
    
    # mean
    mu     <- phys.ellipses.posterior[[i]][j,5:6]
    
    # ellipse points
    
    out <- ellipse::ellipse(Sigma, centre = mu , level = p.ell)
    
    
    ell <- rbind(ell, out)
    post.id <- c(post.id, rep(j, nrow(out)))
    
  }
  ell <- as.data.frame(ell)
  ell$rep <- post.id
  all_ellipses[[i]] <- ell
}

ellipse_df <- bind_rows(all_ellipses, .id = "id")

# now we need the group and community names

# extract them from the global.ellipses.posterior list
group_comm_names <- names(phys.ellipses.posterior)[as.numeric(ellipse_df$id)]

# split them and convert to a matrix, NB byrow = T
split_group_comm <- matrix(
  #unlist(strsplit(group_comm_names, "[.]")),
         unlist(regmatches(group_comm_names, regexpr("[.]", group_comm_names), invert = TRUE)),
                           nrow(ellipse_df), 2, byrow = TRUE)

ellipse_df$community <- split_group_comm[,1]
ellipse_df$group     <- split_group_comm[,2]

ellipse_df <- dplyr::rename(ellipse_df, iso1 = x, iso2 = y)

plot.ellipse.df <- ellipse_df %>% 
  separate(group, into = c("Site", "Genotype", "Origin"), sep = "_") %>% 
  rename(`Time Period` = community, MDS1 = iso1, MDS2 = iso2)

#example niche ellipse plots 
(phys.niche.ellipse.plot <- ggplot(plot.ellipse.df,
                                  aes(x = MDS1, y = MDS2, color = Origin, fill = Genotype))+
    stat_conf_ellipse(geom = "polygon")+
    facet_grid(Site ~ `Time Period`, scales = "free")+
    scale_fill_viridis_d(end = 0.8)+
    scale_color_viridis_d(end = 0.8, option = "A")+
    theme_bw()
)

ggsave(filename = "iso_niche_ellipse_plot.tiff", plot = iso.niche.ellipse.plot,
       height = 150, width = 200, units = "mm", dpi = 300)
```